import { Request, Response } from "express";
import { eq } from "drizzle-orm";
import { db } from "../db";
import { users } from "../../db/schema/users";

export async function updateTheme(req: Request, res: Response) {
  try {
    if (!req.session.user?.id) {
      return res.status(401).json({ message: "Not authenticated" });
    }

    const { theme } = req.body;
    if (theme !== 'light' && theme !== 'dark') {
      return res.status(400).json({ message: "Invalid theme value" });
    }

    // First check if user exists
    const userExists = await db
      .select({ id: users.id })
      .from(users)
      .where(eq(users.id, req.session.user.id));

    if (!userExists.length) {
      return res.status(404).json({ message: "User not found" });
    }

    // Update theme
    await db
      .update(users)
      .set({ theme })
      .where(eq(users.id, req.session.user.id));

    res.json({ theme });
  } catch (error) {
    console.error('Update theme error:', error);
    res.status(500).json({ message: "Error updating theme preference" });
  }
}

export async function getTheme(req: Request, res: Response) {
  try {
    if (!req.session.user?.id) {
      return res.status(401).json({ message: "Not authenticated" });
    }

    // Get user's theme preference
    const result = await db
      .select()
      .from(users)
      .where(eq(users.id, req.session.user.id));

    if (!result.length) {
      return res.status(404).json({ message: "User not found" });
    }

    const theme = result[0].theme || 'light';
    res.json({ theme });
  } catch (error) {
    console.error('Get theme error:', error);
    res.status(500).json({ message: "Error getting theme preference" });
  }
}
import { Router } from 'express';
import { requireAdmin } from './auth';
import { analyticsStore } from '../lib/analytics-store';

const router = Router();

// Get all analytics data in a single request
router.get('/data', requireAdmin, async (req, res) => {
  try {
    const period = req.query.period as string || '24h';
    const [overview, usageData, topUsers, contentStats] = await Promise.all([
      analyticsStore.getOverview(period),
      analyticsStore.getUsageData(period),
      analyticsStore.getTopUsers(),
      analyticsStore.getContentStats()
    ]);

    const analyticsData = {
      overview,
      usageData,
      topUsers,
      contentStats
    };
    
    console.log('Analytics data being sent:', analyticsData);
    res.json(analyticsData);
  } catch (error) {
    console.error('Analytics data error:', error);
    res.status(500).json({ error: 'Failed to fetch analytics data' });
  }
});

export default router;
import { Router, type Express } from "express";
import { signUp, signIn, signOut, checkAuth, checkAdmin, requireAdmin, getUsers, updateUser, updateUserPassword } from "./auth";
import { updateTheme, getTheme } from "./user";
import analyticsRoutes from "./analytics";
import flashcardRoutes from "./flashcards";

export function registerRoutes(app: Express): void {
  const router = Router();

  // Auth routes - Email/Password only
  router.post('/api/auth/signup', signUp);
  router.post('/api/auth/signin', signIn);
  router.post('/api/auth/signout', signOut);
  router.get('/api/auth/check', checkAuth);
  router.get('/api/auth/check-admin', checkAdmin);

  // User routes
  router.get('/api/user/theme', getTheme);
  router.put('/api/user/theme', updateTheme);

  // Admin routes
  router.get('/api/admin/users', requireAdmin, getUsers);
  router.put('/api/admin/users/:id', requireAdmin, updateUser);
  router.put('/api/admin/users/:id/password', requireAdmin, updateUserPassword);

  // Analytics routes
  router.use('/api/analytics', analyticsRoutes);

  // Flashcard routes
  router.use('/api/flashcards', flashcardRoutes);

  // Use the router middleware
  app.use(router);
}
import { Request, Response, NextFunction } from "express";
import { eq } from "drizzle-orm";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import { db } from "../db";
import { users } from "../../db/schema/users";
import { sql } from "drizzle-orm";
import { env } from "../lib/env";
const { JWT_SECRET } = env;

export async function signUp(req: Request, res: Response) {
  try {
    const { firstName, lastName, email, password } = req.body;

    // Check if user already exists
    const existingUser = await db.select().from(users).where(eq(users.email, email));
    if (existingUser.length > 0) {
      return res.status(400).json({ message: "User already exists" });
    }

    // Hash password
    const salt = await bcrypt.genSalt(10);
    const passwordHash = await bcrypt.hash(password, salt);

    // Create user
    const [newUser] = await db.insert(users).values({
      firstName,
      lastName,
      email,
      passwordHash,
    }).returning();

    // Generate JWT token
    const token = jwt.sign({ userId: newUser.id }, JWT_SECRET, { expiresIn: '24h' });

    res.status(201).json({ token });
  } catch (error) {
    console.error('Sign up error:', error);
    res.status(500).json({ message: "Error creating user" });
  }
}

// Add session check endpoint
export async function checkAuth(req: Request, res: Response) {
  try {
    console.log('Auth check - Session data:', {
      sessionId: req.session.id,
      sessionUser: req.session.user,
      authenticated: req.session.authenticated,
      cookie: req.session.cookie
    });

    if (!req.session) {
      console.log('No session found');
      return res.status(401).json({ authenticated: false, error: 'No session' });
    }

    if (!req.session.user?.id) {
      console.log('No user in session');
      return res.status(401).json({ authenticated: false, error: 'No user in session' });
    }

    // Verify user still exists in database
    const [user] = await db
      .select({
        id: users.id,
        email: users.email,
        isAdmin: users.isAdmin,
        theme: users.theme
      })
      .from(users)
      .where(eq(users.id, req.session.user.id))
      .limit(1);

    if (!user) {
      console.log('User not found in database, clearing session');
      req.session.destroy((err: Error | null) => {
        if (err) console.error('Session destruction error:', err);
      });
      return res.status(401).json({ authenticated: false, error: 'User not found' });
    }

    // Update session data
    req.session.user = {
      id: user.id,
      email: user.email,
      isAdmin: user.isAdmin
    };
    req.session.authenticated = true;

    // Save session explicitly
    await new Promise<void>((resolve, reject) => {
      req.session.save((err: Error | null) => {
        if (err) {
          console.error('Session save error:', err);
          reject(err);
        } else {
          console.log('Session saved successfully');
          resolve();
        }
      });
    });

    console.log('Auth check successful for user:', user.id);
    res.json({ 
      authenticated: true, 
      user: { 
        id: user.id, 
        email: user.email,
        isAdmin: user.isAdmin,
        theme: user.theme || 'light'
      } 
    });
  } catch (error) {
    console.error('Auth check error:', error);
    res.status(500).json({ 
      authenticated: false, 
      error: 'Internal server error during auth check' 
    });
  }
}

export async function signIn(req: Request, res: Response) {
  try {
    const { email, password } = req.body;

    // Find user
    const [user] = await db.select({
      id: users.id,
      email: users.email,
      passwordHash: users.passwordHash,
      isAdmin: users.isAdmin,
      theme: users.theme
    }).from(users).where(eq(users.email, email));
    if (!user) {
      return res.status(401).json({ message: "Invalid credentials" });
    }

    // Verify password
    const isValidPassword = await bcrypt.compare(password, user.passwordHash);
    if (!isValidPassword) {
      return res.status(401).json({ message: "Invalid credentials" });
    }

    try {
      console.log('Setting up session for user:', user.id);
      
      // Set user session
      req.session.user = {
        id: user.id,
        email: user.email,
        isAdmin: user.isAdmin
      };
      req.session.authenticated = true;
      
      console.log('Session data before save:', req.session);
      
      // Save session before responding
      await new Promise<void>((resolve, reject) => {
        req.session.save((err: Error | null) => {
          if (err) {
            console.error('Session save error:', err);
            reject(err);
          } else {
            console.log('Session saved successfully');
            resolve();
          }
        });
      });
      
      console.log('Final session state:', {
        id: req.session.id,
        user: req.session.user,
        authenticated: req.session.authenticated
      });
    } catch (sessionError) {
      console.error('Session creation error:', sessionError);
      return res.status(500).json({ message: "Error creating session" });
    }
    
    // Also send JWT token for API authentication
    const token = jwt.sign({ userId: user.id }, JWT_SECRET!, { expiresIn: '24h' });

    // Include theme in the response
    res.json({ 
      token, 
      user: { 
        id: user.id, 
        email: user.email,
        theme: user.theme || 'light',
        isAdmin: user.isAdmin || false
      } 
    });
  } catch (error) {
    console.error('Sign in error:', error);
    res.status(500).json({ message: "Error signing in" });
  }
}
export async function signOut(req: Request, res: Response) {
  try {
    // Clear user session from database if user exists
    if (req.session?.user?.id) {
      try {
        await db.execute(sql`
          UPDATE user_sessions 
          SET ended_at = NOW() 
          WHERE user_id = ${req.session.user.id} 
          AND ended_at IS NULL
        `);
      } catch (dbError) {
        console.error('Database error during sign out:', dbError);
        // Continue with session destruction even if DB update fails
      }
    }

    // Clear authentication flag
    req.session.authenticated = false;
    req.session.user = undefined;

    // Destroy session and clear cookie
    return new Promise<void>((resolve) => {
      req.session.destroy((err: Error | null) => {
        if (err) {
          console.error('Error destroying session:', err);
          res.status(500).json({ message: "Error signing out" });
        } else {
          res.clearCookie('sid', {
            path: '/',
            httpOnly: true,
            secure: env.NODE_ENV === 'production',
            sameSite: 'lax'
          });
          res.json({ message: "Signed out successfully" });
        }
        resolve();
      });
    });
  } catch (error) {
    console.error('Sign out error:', error);
    res.status(500).json({ message: "Error signing out" });
  }
}

export async function checkAdmin(req: Request, res: Response) {
  try {
    if (!req.session.user?.id) {
      return res.status(401).json({ message: "Not authenticated" });
    }

    const [user] = await db
      .select({
        isAdmin: users.isAdmin
      })
      .from(users)
      .where(eq(users.id, req.session.user.id))
      .limit(1);

    console.log('Admin check for user:', req.session.user.id, 'Result:', user);
    
    res.json({ isAdmin: user?.isAdmin || false });
  } catch (error) {
    console.error('Error checking admin status:', error);
    res.status(500).json({ message: "Error checking admin status" });
  }
}

// Admin middleware to check if user is admin
export async function requireAdmin(req: Request, res: Response, next: NextFunction) {
  try {
    if (!req.session.user?.id) {
      return res.status(401).json({ message: "Not authenticated" });
    }

    const [user] = await db
      .select({
        isAdmin: users.isAdmin
      })
      .from(users)
      .where(eq(users.id, req.session.user.id))
      .limit(1);

    if (!user?.isAdmin) {
      return res.status(403).json({ message: "Not authorized" });
    }

    next();
  } catch (error) {
    console.error('Error in admin middleware:', error);
    res.status(500).json({ message: "Error checking admin status" });
  }
}

// Get all users (admin only)
export async function getUsers(req: Request, res: Response) {
  try {
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 10;
    const search = (req.query.search as string) || '';
    const offset = (page - 1) * limit;

    type UserSelect = typeof users.$inferSelect;
    
    const baseQuery = db.select({
      id: users.id,
      firstName: users.firstName,
      lastName: users.lastName,
      email: users.email,
      isAdmin: users.isAdmin,
      createdAt: users.createdAt
    }).from(users);

    // Add search condition if search query exists
    const query = search 
      ? baseQuery.where(
          sql`LOWER(${users.firstName}) LIKE LOWER(${'%' + search + '%'}) OR 
              LOWER(${users.lastName}) LIKE LOWER(${'%' + search + '%'}) OR 
              LOWER(${users.email}) LIKE LOWER(${'%' + search + '%'})`
        )
      : baseQuery;

    // Get total count for pagination
    const [{ count }] = await db.select({
      count: sql<number>`count(*)::int`
    }).from(users);

    // Get paginated results
    const usersList = await query.limit(limit).offset(offset);

    res.json({
      users: usersList,
      pagination: {
        total: count,
        page,
        limit,
        totalPages: Math.ceil(count / limit)
      }
    });
  } catch (error) {
    console.error('Error fetching users:', error);
    res.status(500).json({ message: "Error fetching users" });
  }
}

// Update user (admin only)
export async function updateUser(req: Request, res: Response) {
  try {
    const userId = parseInt(req.params.id);
    const { firstName, lastName, email, isAdmin } = req.body;

    // Validate inputs
    if (!firstName || !lastName || !email) {
      return res.status(400).json({ message: "Missing required fields" });
    }

    // Check if email is taken by another user
    const existingUser = await db
      .select()
      .from(users)
      .where(sql`${users.email} = ${email} AND ${users.id} != ${userId}`);

    if (existingUser.length > 0) {
      return res.status(400).json({ message: "Email already taken" });
    }

    // Prevent admin from removing their own admin status
    if (req.session.user?.id === userId && isAdmin === false) {
      return res.status(400).json({ message: "Cannot remove your own admin status" });
    }

    // Update user
    const [updatedUser] = await db
      .update(users)
      .set({
        firstName,
        lastName,
        email,
        ...(typeof isAdmin === 'boolean' ? { isAdmin } : {})
      })
      .where(eq(users.id, userId))
      .returning();

    console.log('Updated user:', updatedUser);
    res.json(updatedUser);
  } catch (error) {
    console.error('Error updating user:', error);
    res.status(500).json({ message: "Error updating user" });
  }
}

// Update user password (admin only)
export async function updateUserPassword(req: Request, res: Response) {
  try {
    const userId = parseInt(req.params.id);
    const { password } = req.body;

    if (!password || typeof password !== 'string') {
      return res.status(400).json({ message: "Invalid password" });
    }

    // Hash the new password
    const salt = await bcrypt.genSalt(10);
    const passwordHash = await bcrypt.hash(password, salt);

    // Update user's password
    const [updatedUser] = await db
      .update(users)
      .set({ passwordHash })
      .where(eq(users.id, userId))
      .returning();

    console.log('Updated user password:', userId);
    res.json({ message: "Password updated successfully" });
  } catch (error) {
    console.error('Error updating user password:', error);
    res.status(500).json({ message: "Error updating user password" });
  }
}import { Router } from 'express';
import multer from 'multer';
import { storage } from '../lib/storage';
import { db } from '../db';
import { flashcardSets, flashcards } from '@db/schema/flashcards';
import { users } from '@db/schema/users';
import { eq } from 'drizzle-orm';
import { Request } from 'express';
import { Session } from 'express-session';
import { parse } from 'csv-parse';

interface AuthenticatedRequest extends Request {
  session: Session & {
    user?: {
      id: number;
      email?: string;
      isAdmin?: boolean;
    };
    authenticated?: boolean;
  };
}

const router = Router();

// Configure multer for memory storage
const upload = multer({ 
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB limit
  },
  fileFilter: (_req, file, cb) => {
    if (!file.originalname.toLowerCase().endsWith('.csv')) {
      cb(new Error('Only CSV files are allowed'));
      return;
    }
    cb(null, true);
  }
});

// Handle file upload and create flashcard set
router.post('/', upload.single('file'), async (req: AuthenticatedRequest, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    if (!req.session?.user?.id) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    // Parse CSV file
    const csvContent = req.file.buffer.toString('utf-8');
    const cards = await new Promise<any[]>((resolve, reject) => {
      parse(csvContent, {
        columns: true,
        skip_empty_lines: true,
        trim: true,
      })
      .on('data', (data) => resolve([data]))
      .on('error', (error) => reject(error));
    });

    // Validate required columns
    const requiredColumns = ['Vocab Word', 'Identifying Part Of Speach', 'Definition', 'Example Sentance'];
    const missingColumns = requiredColumns.filter(col => !cards[0] || !(col in cards[0]));
    
    if (missingColumns.length > 0) {
      return res.status(400).json({ 
        error: `Missing required columns: ${missingColumns.join(', ')}`
      });
    }

    // Create unique file path for Object Storage
    const timestamp = Date.now();
    const sanitizedFilename = req.file.originalname.replace(/[^a-zA-Z0-9.-]/g, '_');
    const filePath = `flashcards/${req.session.user.id}/${timestamp}_${sanitizedFilename}`;

    // Upload to Object Storage
    console.log('Uploading to Object Storage:', {
      path: filePath,
      size: req.file.buffer.length,
      timestamp: new Date().toISOString()
    });

    const uploadResult = await storage.upload(filePath, req.file.buffer);
    if (!uploadResult.success) {
      throw new Error(`Storage upload failed: ${uploadResult.error}`);
    }

    // Create flashcard set
    const [newSet] = await db.insert(flashcardSets).values({
      userId: req.session.user.id,
      title: req.file.originalname.replace(/\.[^/.]+$/, ""),
      isPublic: false,
      tags: [] as string[],
      urlPath: `sets/${timestamp}`,
      filePath: filePath,
      createdAt: new Date(),
      updatedAt: new Date()
    }).returning();

    try {
      // Map cards data to schema
      const cardValues = cards.map((card, index) => ({
        setId: newSet.id,
        vocabWord: card['Vocab Word'],
        partOfSpeech: card['Identifying Part Of Speach'],
        definition: card['Definition'],
        exampleSentence: card['Example Sentance'],
        position: index + 1
      }));

      // Insert flashcards
      await db.insert(flashcards).values(cardValues);

      // Generate download URL for immediate access
      const downloadResult = await storage.download(filePath);
      
      res.status(201).json({
        message: 'File uploaded successfully',
        flashcardSet: {
          id: newSet.id,
          title: newSet.title,
          filePath: filePath,
          urlPath: newSet.urlPath,
          downloadUrl: downloadResult.presignedUrl,
          createdAt: newSet.createdAt
        }
      });
    } catch (error) {
      // Cleanup on failure
      await storage.delete(filePath).catch(err => 
        console.error('Cleanup error:', err)
      );
      throw error;
    }
  } catch (error) {
    console.error('Upload error:', error);
    res.status(500).json({ 
      error: error instanceof Error ? error.message : 'Failed to process upload'
    });
  }
});

export default router;import { Router, Request } from 'express';
import { eq } from 'drizzle-orm';
import multer from 'multer';
import { body, validationResult } from 'express-validator';
import { db, query } from '@db/index';
import { flashcardSets, flashcards, memorizationSessions } from '@db/schema/flashcards';
import type { FlashcardSet, Flashcard, MemorizationSession } from '@db/index';
import { storage } from '../lib/storage';

// Extend Express Request type to include user
interface AuthenticatedRequest extends Request {
  session: {
    user?: {
      id: number;
      email: string;
      isAdmin?: boolean;
    };
    authenticated?: boolean;
  };
}

const router = Router();
const upload = multer();

// Handle file upload for flashcard sets
router.post('/sets/upload', upload.single('file'), async (req: AuthenticatedRequest, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    // Validate file type
    if (!req.file.originalname.toLowerCase().endsWith('.csv')) {
      return res.status(400).json({ error: 'Invalid file type. Only CSV files are allowed.' });
    }

    // Validate file size (5MB limit)
    const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB in bytes
    if (req.file.size > MAX_FILE_SIZE) {
      return res.status(400).json({ error: 'File size exceeds 5MB limit.' });
    }

    const userId = req.session.user?.id;
    if (!userId) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    // Create flashcard set first to get the setId
    const [flashcardSet] = await db.insert(flashcardSets).values({
      userId,
      title: req.file.originalname.replace(/\.[^/.]+$/, ""), // Remove file extension
      isPublic: false,
      tags: [], // PostgreSQL array
      createdAt: new Date(),
      updatedAt: new Date(),
      urlPath: `/preview/${Date.now()}`, // Add URL path for frontend routing
      filePath: null // Will be updated after successful upload
    }).returning();

    try {
      // Create a unique file path for storage
      const fileName = `flashcards/${userId}/${flashcardSet.id}/${req.file.originalname}`;
      
      // Upload file using storage service
      await storage.upload(fileName, req.file.buffer);

      // Update the set with the file path after successful upload
      const [updatedSet] = await db.update(flashcardSets)
        .set({ 
          filePath: fileName,
          updatedAt: new Date()
        })
        .where(eq(flashcardSets.id, flashcardSet.id))
        .returning();

      if (!updatedSet) {
        throw new Error('Failed to update flashcard set with file path');
      }

      res.status(201).json({ 
        message: 'File uploaded successfully',
        flashcardSet: updatedSet
      });
    } catch (error) {
      console.error('Error uploading file:', error);
      
      // Cleanup the created set if upload fails
      if (flashcardSet?.id) {
        await db.delete(flashcardSets)
          .where(eq(flashcardSets.id, flashcardSet.id))
          .catch(err => console.error('Cleanup error:', err));
      }
      
      res.status(500).json({ 
        error: error instanceof Error ? error.message : 'Failed to upload file'
      });
    }
  } catch (error) {
    console.error('Error handling upload:', error);
    res.status(500).json({ 
      error: error instanceof Error ? error.message : 'Failed to process upload'
    });
  }
});

// Create a new flashcard set
router.post('/sets', 
  body('title').notEmpty().trim(),
  body('description').optional().trim(),
  body('isPublic').optional().isBoolean(),
  body('tags').optional().isArray(),
  async (req: AuthenticatedRequest, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }

      const { title, description, isPublic, tags } = req.body;
      const userId = req.session.user?.id;

      if (!userId) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      const [newSet] = await db.insert(flashcardSets).values({
        userId,
        title,
        description,
        isPublic: isPublic || false,
        tags: tags ? tags as string[] : [],
        createdAt: new Date(),
        updatedAt: new Date()
      }).returning();

      res.status(201).json(newSet);
    } catch (error) {
      console.error('Error creating flashcard set:', error);
      res.status(500).json({ error: 'Failed to create flashcard set' });
    }
});

// Add flashcards to a set
router.post('/sets/:setId/cards',
  body('cards').isArray(),
  body('cards.*.vocabWord').notEmpty().trim(),
  body('cards.*.partOfSpeech').notEmpty().trim(),
  body('cards.*.definition').notEmpty().trim(),
  body('cards.*.exampleSentence').optional().trim(),
  async (req: AuthenticatedRequest, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }

      const { setId } = req.params;
      const { cards } = req.body;
      const userId = req.session.user?.id;

      if (!userId) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      // Verify set ownership
      const set = await query.flashcardSets.findWithCards(parseInt(setId));

      if (!set || set.userId !== userId) {
        return res.status(403).json({ error: 'Forbidden' });
      }

      // Insert all cards with positions
      const cardValues = cards.map((card: {
        vocabWord: string;
        partOfSpeech: string;
        definition: string;
        exampleSentence?: string;
      }, index: number) => ({
        setId: parseInt(setId),
        vocabWord: card.vocabWord,
        partOfSpeech: card.partOfSpeech,
        definition: card.definition,
        exampleSentence: card.exampleSentence,
        position: index + 1
      }));

      const newCards = await db.insert(flashcards).values(cardValues).returning();
      res.status(201).json(newCards);
    } catch (error) {
      console.error('Error adding flashcards:', error);
      res.status(500).json({ error: 'Failed to add flashcards' });
    }
});

// Get user's uploaded files
router.get('/sets/files', async (req: AuthenticatedRequest, res) => {
  try {
    const userId = req.session.user?.id;
    if (!userId) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const userPrefix = `flashcards/${userId}/`;
    const filesResult = await storage.list(userPrefix);
    
    if (!filesResult.success) {
      console.error('Failed to list files:', filesResult.error);
      // Continue without files, we can still return sets from database
    }

    // Get all flashcard sets for the user
    const sets = await db.query.flashcardSets.findMany({
      where: eq(flashcardSets.userId, userId),
      orderBy: [flashcardSets.createdAt],
    });

    const filesWithMetadata = sets.map(set => ({
      ...set,
      downloadUrl: null as string | null
    }));

    // Get download URLs for all files
    for (const file of filesWithMetadata) {
      if (file.filePath) {
        const downloadResult = await storage.download(file.filePath);
        if (downloadResult.presignedUrl) {
          file.downloadUrl = downloadResult.presignedUrl;
        }
      }
    }

    res.json(filesWithMetadata);
  } catch (error) {
    console.error('Error listing files:', error);
    res.status(500).json({ error: error instanceof Error ? error.message : 'Failed to list files' });
  }
});

// Download a specific file
router.get('/sets/:setId/download', async (req: AuthenticatedRequest, res) => {
  try {
    const { setId } = req.params;
    const userId = req.session.user?.id;
    
    if (!userId) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    // Get the flashcard set
    const set = await db.query.flashcardSets.findFirst({
      where: eq(flashcardSets.id, parseInt(setId)),
    });

    if (!set || set.userId !== userId) {
      return res.status(403).json({ error: 'Forbidden' });
    }

    if (!set.filePath) {
      return res.status(404).json({ error: 'No file associated with this set' });
    }

    // Get the file extension to determine content type
    const ext = set.filePath.split('.').pop()?.toLowerCase();
    const contentType = ext === 'png' ? 'image/png' 
                     : ext === 'jpg' || ext === 'jpeg' ? 'image/jpeg'
                     : ext === 'csv' ? 'text/csv'
                     : 'application/octet-stream';

    const downloadResult = await storage.download(set.filePath);
    
    if (!downloadResult.success || !downloadResult.presignedUrl) {
      console.error('Download failed:', downloadResult.error);
      return res.status(404).json({ error: 'File not found or inaccessible' });
    }

    // For images and other binary files, return the URL directly
    if (contentType.startsWith('image/')) {
      return res.json({ 
        downloadUrl: downloadResult.presignedUrl,
        contentType
      });
    }

    // For CSV files, keep existing behavior
    res.json({ 
      downloadUrl: downloadResult.presignedUrl,
      contentType
    });
  } catch (error) {
    console.error('Error downloading file:', error);
    res.status(500).json({ error: error instanceof Error ? error.message : 'Failed to download file' });
  }
});

// Get preview data for a set
// Get preview data for a set
router.get('/sets/:setId/preview', async (req: AuthenticatedRequest, res) => {
  try {
    const { setId } = req.params;
    const userId = req.session.user?.id;
    
    if (!userId) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    // Get the flashcard set with its cards
    const set = await db.query.flashcardSets.findFirst({
      where: eq(flashcardSets.id, parseInt(setId)),
      with: {
        cards: {
          orderBy: (cards, { asc }) => [asc(cards.position)]
        }
      }
    });

    if (!set) {
      return res.status(404).json({ error: 'Set not found' });
    }

    if (set.userId !== userId) {
      return res.status(403).json({ error: 'Forbidden' });
    }

    // Get download URL if there's a file
    let downloadUrl = null;
    if (set.filePath) {
      try {
        const downloadResult = await storage.download(set.filePath);
        if (downloadResult.success && downloadResult.presignedUrl) {
          downloadUrl = downloadResult.presignedUrl;
        }
      } catch (err) {
        console.error('Error generating download URL:', err);
      }
    }

    console.log('Preview data:', {
      setId,
      userId,
      hasFile: !!set.filePath,
      downloadUrl: !!downloadUrl
    });

    res.json({ 
      set: {
        ...set,
        downloadUrl
      },
      cards: set.cards 
    });
  } catch (error) {
    console.error('Error getting preview:', error);
    res.status(500).json({ error: error instanceof Error ? error.message : 'Failed to get preview' });
  }
});

// Handle file downloads
router.get('/sets/:setId/download', async (req: AuthenticatedRequest, res) => {
  try {
    const { setId } = req.params;
    const userId = req.session.user?.id;
    
    if (!userId) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const set = await db.query.flashcardSets.findFirst({
      where: eq(flashcardSets.id, parseInt(setId))
    });

    if (!set) {
      return res.status(404).json({ error: 'Set not found' });
    }

    if (set.userId !== userId) {
      return res.status(403).json({ error: 'Forbidden' });
    }

    if (!set.filePath) {
      return res.status(404).json({ error: 'No file associated with this set' });
    }

    const downloadResult = await storage.download(set.filePath);
    if (!downloadResult.success || !downloadResult.presignedUrl) {
      throw new Error('Failed to generate download URL');
    }

    // Determine content type based on file extension
    const contentType = set.filePath.toLowerCase().endsWith('.png') ? 'image/png' :
                       set.filePath.toLowerCase().endsWith('.jpg') ? 'image/jpeg' :
                       'application/octet-stream';

    res.json({ 
      downloadUrl: downloadResult.presignedUrl,
      contentType
    });
  } catch (error) {
    console.error('Download error:', error);
    res.status(500).json({ error: error instanceof Error ? error.message : 'Failed to process download' });
  }
});

export default router;import { Router } from 'express';
import { asyncHandler } from '../middleware/errorHandling';
import type { Request } from 'express';

interface AuthenticatedRequest extends Request {
  session: {
    user?: {
      id: number;
      email: string;
      isAdmin?: boolean;
    };
    authenticated?: boolean;
  };
}

const router = Router();

router.get('/protected', asyncHandler(async (req: AuthenticatedRequest, res) => {
  if (!req.session.authenticated) {
    const error = new Error('Unauthorized');
    error.statusCode = 401;
    throw error;
  }
  
  res.json({ message: 'Protected route accessed successfully' });
}));

export default router;